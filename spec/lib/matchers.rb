require 'diff/lcs'
require 'diff/lcs/callbacks'
require 'pathname'

# Borrowed most of this from the BlueCloth gem at
# https://github.com/ged/bluecloth/blob/master/spec/lib/matchers.rb


module TartanCloth::Matchers

  class TransformMatcher

    def initialize( html )
      @html = html
    end

    ### Strip tab indentation from the expected HTML output.
    def without_indentation
      if indent = @html[/\A\s+/]
        indent.gsub!( /\A\n/m, '' )
        @html.gsub!( /^#{indent}/m, '' )
      end

      return self
    end

    ### Returns true if the HTML generated by the given +tartancloth+ object matches the
    ### expected HTML, comparing only the salient document structures.
    def matches?( tartancloth )
      @tartancloth = tartancloth
      @output_html = tartancloth.body_html.gsub( /\n\n\n/, "\n\n" )
      return @output_html.strip == @html.strip
    end

    def failure_message_for_should
      patch = self.make_patch( @html, @output_html )
      return ("Expected the generated html:\n\n  %p\n\nto be the same as:\n\n" +
        "  %p\n\nDiffs:\n\n%s") % [ @output_html, @html, patch ]
    end

    def failure_message_for_should_not
      return "Expected the generated html:\n\n  %p\n\nnot to be the same as:\n\n  %p\n\n" %
        [ @output_html, @html ]
    end

    ### Compute a patch between the given +expected+ output and the +actual+ output
    ### and return it as a string.
    def make_patch( expected, actual )
      diffs = Diff::LCS.sdiff( expected.split("\n"), actual.split("\n"),
        Diff::LCS::ContextDiffCallbacks )

      maxcol = diffs.flatten.
        collect {|d| [d.old_element.to_s.length, d.new_element.to_s.length ] }.
        flatten.max || 0
      maxcol += 4

      patch = "              %#{maxcol}s | %s\n" % [ "Expected", "Actual" ]
      patch << diffs.collect do |changeset|
        changeset.collect do |change|
          "%s [%03d, %03d]: %#{maxcol}s | %-#{maxcol}s" % [
            change.action,
            change.old_position,
            change.new_position,
            change.old_element.inspect,
            change.new_element.inspect,
          ]
        end.join("\n")
      end.join("\n---\n")
    end

  end # class TransformMatcher


  ### Write markup to temp file
  def write_tmp_file( string )
    tmpfile = Pathname('tmp')
    tmpfile.mkpath
    tmpfile += 'markdown.md'
    File.open( tmpfile.to_s, 'w') do |f|
      f << string
    end
    tmpfile.to_s
  end

  ### Create a new TartanCloth object out of the given +string+ and +options+ and
  ### return it.
  def the_markdown( string )
    return TartanCloth.new( write_tmp_file(string) )
  end


  ### Strip indentation from the given +string+, create a new TartanCloth object
  ### out of the result and any +options+, and return it.
  def the_indented_markdown( string )
    if indent = string[/\A\s+/]
      indent.gsub!( /\A\n/m, '' )
      $stderr.puts "Source indent is: %p" % [ indent ] if $DEBUG
      string.gsub!( /^#{indent}/m, '' )
    end

    return TartanCloth.new( write_tmp_file(string) )
  end


  ### Generate a matcher that expects to equal the given +html+.
  def be_transformed_into( html )
    return TartanCloth::Matchers::TransformMatcher.new( html )
  end

end # module
